# Import required libraries
import json
import os
import random
import re
import urllib
import requests

from rich.console import Console
from rich.errors import MarkupError

from .info import infos, bcolors
from config.pthelper_config import general_config

# Define the base class Exploiter
class Exploiter:
    # Use __new__ to create a new instance of the scanner_class based on the provided mode
    def __new__(cls, mode, scanner_output):
        # A dictionary to map different exploiter modes to respective classes
        exploiter_classes = {
            "exploitdb": ExploitDBExploiter
            # For future exploiter modes, add the user-defined flag and the corresponding child class name here
        }
        # Get the exploiter from the dictionary, default is ExploitDB itself
        exploiter_class = exploiter_classes.get(mode, Exploiter)
        return super(Exploiter, cls).__new__(exploiter_class)

    def __init__(self, mode, scanner_output):
        self.mode = mode
        self.input = scanner_output
        self.console = Console()

        # Print an informative message
        self.console.print(f"Initializing [cyan]{mode}[/] [bright_white]Exploiter[/] module to extract exploits from found CVEs.",
                           style="bold bright_magenta")


# Define a child class ExploitDBExploiter, inheriting from Exploiter
class ExploitDBExploiter(Exploiter):

    # Call the parent class (scanner) to receive parameters.
    def __init__(self, mode, scanner_output):
        # Initialize attributes specific to ExploitDBExploiter
        self.mode = mode
        self.exploit_db = "https://www.exploit-db.com/"
        self.exploit_db_git = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/"
        self.command = ''
        self.usage = ''
        self.lang = None
        self.findlang = None
        self.scanner_output = scanner_output

        # Set the path for storing exploits
        self.EXPLOIT_PATH = os.path.join(general_config.PROJECTPATH, 'exploits/')

        # Read User-Agent headers from a file and select a random one
        ua = open('pthelper/exploiter/headers.txt').read().splitlines()
        self.header = {"User-Agent": random.choice(ua), "X-Requested-With": "XMLHttpRequest"}

        # Call the parent class constructor
        super().__init__(mode, scanner_output)

    # Method to detect compilation options based on payload and language
    def DetectCompilationOptions(self, payload, cve_id, name, name_ext):

        try:
            # Detect compilation options for C/C++
            if self.lang == "c" or self.lang == "c++":
                try:
                    # Try to extract compilation command from payload
                    self.command = re.search(r"((gcc|g\+\+) .*?)(\\r\\n|\\n)", str(payload)).group(1)

                    if self.command != '':
                        # Modify compilation command to include file paths
                        # and other necessary flags
                        self.command = re.sub(' \S*\.cpp', f' {self.EXPLOIT_PATH} ' + str(name) + '.cpp', self.command).strip(
                            "\"")
                        self.command = re.sub(' \S*\.c', f' {self.EXPLOIT_PATH} ' + str(name) + '.c', self.command).strip("\"")
                        self.command = re.sub('-o \S*', f'-o {self.EXPLOIT_PATH}' + str(name), self.command).strip("\"")

                        # Print detected compilation options
                        self.console.print(
                            f"[[bold bright_green]+[/]] Compiling options detected: {self.command}[/]",
                            style="bright_white")
                except:
                    # If command extraction fails, use a default compilation command
                    self.command = f"gcc {self.EXPLOIT_PATH}" + cve_id + "_" + name_ext + f" -o {self.EXPLOIT_PATH}" + str(name)
                    # Print default compilation options
                    # Print detected compilation options
                    self.console.print(
                        f"[[bold bright_yellow]?[/]] Compiling options not detected: {self.command}[/]",
                        style="bright_white")

                payload_split = payload.splitlines()
                usage = re.search("(\.\/.*?)(\',/\",)", str(payload_split)).group(1)
                if usage != '':
                    usage = re.sub('(\.\/.*? )', f' {self.EXPLOIT_PATH}' + str(name) + ' ', usage)
                    self.console.print(
                        f"[[bold bright_yellow]+[/]] Usage detected: [bold bright_green]{usage}[/]",
                        style="bright_white")

            # Detect compilation options for other languages (bash, ruby, perl, python, etc.)
            # Also, extract usage information and modify it based on exploit file paths
            elif self.lang == "bash":
                usage = re.search(r"(sh .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.sh', f' {self.EXPLOIT_PATH}' + str(name_ext), usage)
                    self.console.print(f"[[bold bright_yellow]+[/]] Usage detected: [bold bright_green]{usage}[/]",
                                       style="bright_white")

            elif self.lang == "ruby":
                usage = re.search(r"(ruby .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.rb', f' {self.EXPLOIT_PATH}' + str(name_ext), usage)
                    self.console.print(f"[[bold bright_yellow]+[/]] Usage detected: [bold bright_green]{usage}[/]",
                                       style="bright_white")

            elif self.lang == "perl":
                usage = re.search(r"(perl .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.pl', f' {self.EXPLOIT_PATH}' + str(name_ext), usage)
                    self.console.print(f"[[bold bright_yellow]+[/]] Usage detected: [bold bright_green]{usage}[/]",
                                       style="bright_white")

            elif self.lang == "python":
                usage = re.search(r"(python .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.py', f' {self.EXPLOIT_PATH}' + str(name_ext), usage)
                    self.console.print(f"[[bold bright_yellow]+[/]] Usage detected: [bold bright_green]{usage}[/]",
                                       style="bright_white")

            elif self.lang == "php":
                usage = re.search(r"(php .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.php', f' {self.EXPLOIT_PATH}' + str(name_ext), usage)
                    self.console.print(f"[[bold bright_yellow]+[/]] Usage detected: [bold bright_green]{usage}[/]",
                                       style="bright_white")



        # Handle exceptions and set default usage information
        except AttributeError:
            # Set default usage information for different languages
            if self.lang == "c" or self.lang == "c++":
                usage = f"{self.EXPLOIT_PATH}" + str(name)

            elif self.lang == "bash":
                usage = f"sh {self.EXPLOIT_PATH}" + str(name_ext)

            elif self.lang == "ruby":
                usage = f"ruby {self.EXPLOIT_PATH}" + str(name_ext)

            elif self.lang == "perl":
                usage = f"perl {self.EXPLOIT_PATH}" + str(name_ext)

            elif self.lang == "python":
                usage = f"python {self.EXPLOIT_PATH}" + str(name_ext)

            elif self.lang == "php":
                usage = f"php {self.EXPLOIT_PATH}" + str(name_ext)

            self.console.print(f"[[bold bright_red]-[/]] Usage not detected, by default: [bold]{usage}[/]",
                                   style="bright_white")

    # Method to guess programming language based on file extension and payload content
    def GuessLang(self, sub_url, payload):

        # Define wordlists to identify programming languages and frameworks
        metasploit_wordlist = ["MetasploitModule", "Msf::Exploit"]

        # Determine programming language based on file extension
        # Set appropriate language and color for display
        if sub_url[-4:] == ".cpp":
            self.findlang = " - " + bcolors.CYAN + bcolors.BOLD + "c++" + bcolors.ENDC + bcolors.ENDC
            self.lang = "c++"
        elif sub_url[-2:] == ".c":
            self.findlang = " - " + bcolors.CYAN + bcolors.BOLD + "c" + bcolors.ENDC + bcolors.ENDC
            self.lang = "c"
        elif sub_url[-3:] == ".sh":
            self.findlang = " - " + bcolors.GREEN + bcolors.BOLD + "sh" + bcolors.ENDC + bcolors.ENDC
            self.lang = "bash"
        elif sub_url[-3:] == ".rb":
            self.findlang = " - " + bcolors.RED + bcolors.BOLD + "ruby" + bcolors.ENDC + bcolors.ENDC
            self.lang = "ruby"
            for word in metasploit_wordlist:
                if word in payload:
                    self.findlang = " - " + bcolors.RED + bcolors.BOLD + "metasploit" + bcolors.ENDC + bcolors.ENDC
                    lang = "metasploit"
        elif sub_url[-3:] == ".pl":
            self.findlang = " - " + bcolors.PURPLE + bcolors.BOLD + "perl" + bcolors.ENDC + bcolors.ENDC
            self.lang = "perl"
        elif sub_url[-3:] == ".py":
            self.findlang = " - " + bcolors.OCRA + bcolors.BOLD + "python" + bcolors.ENDC + bcolors.ENDC
            self.lang = "python"
        elif sub_url[-4:] == ".php":
            self.findlang = " - " + bcolors.BLUE + bcolors.BOLD + "php" + bcolors.ENDC + bcolors.ENDC
            self.lang = "php"
        elif sub_url[-4:] == ".txt" or sub_url[-5:] == ".html":
            self.findlang = " - " + bcolors.BOLD + "text" + bcolors.ENDC
            self.lang = "text"
        elif sub_url[-4:] == ".jsp":
            self.findlang = " - " + bcolors.OCRA + bcolors.BOLD + "jsp" + bcolors.ENDC + bcolors.ENDC
            self.lang = "jsp"

    # Method to process and display information about found CVEs
    def CVEFound(self, detect_edb, description, sub_url):

        # Fetch payload content from ExploitDB
        sock_edb = urllib.request.urlopen(self.exploit_db_git + sub_url)
        payload = sock_edb.read()
        sock_edb.close()

        # Guess the programming language of the payload
        self.GuessLang(sub_url, str(payload))

        # Display exploit information and language
        if payload != "":
            if description == None:
                print(
                    bcolors.RED + bcolors.BOLD + "EDB-" + bcolors.ENDC + bcolors.ENDC + detect_edb + " : " + "No description found.")
            else:
                print(bcolors.RED + bcolors.BOLD + "EDB-" + bcolors.ENDC + bcolors.ENDC + detect_edb + " : " + str(
                    description) + self.findlang)

    # Method to search for CVEs related to a specific software version
    def Socket(self, software, url):

        socket = requests.get(url, headers=self.header)

        # Fetch data from the provided URL and filter relevant lines
        lines = socket.text.split('\n')
        # Search for CVEs related to the specified software version
        socket = re.findall(".*(?i)" + software + ".*", socket.text)

        # Display CVE information or a message if none are found
        if socket == None or socket == []:
            self.console.print(f"[[bold bright_green]+[/]] No CVEs found for this software version.",
                               style="bright_white")

        else:
            self.console.print(f"[[bold bright_green]+[/]] Exploits found for this CVE",
                               style="bright_white")
            for record in socket:
                record_split = record.split(',')
                try:
                    description = record_split[2]
                    detect_edb = record_split[0]
                    sub_url = record_split[1]
                except IndexError:
                    pass
                # Calls a method to process and display this information
                self.CVEFound(detect_edb, description, sub_url)

        return socket

    # Method to search for exploits related to a specific software.
    # This method calls another subroutine to perform its action.
    def SearchExploit(self, software):

        if software == None:
            pass

        # Display search progress and URL being used
        else:
            print(infos.PROCESS + "SEARCHING...")
            url = self.exploit_db_git + "files_exploits.csv"
            print(infos.INFO + "SEARCHING FOR : " + url + " - " + software)
            # Call the Socket method to search for exploits
            self.Socket(software, url)

    # Method to handle compilation of exploits in various languages
    def Compilation(self, name, command, language):

        # Set default compilation command for different languages
        if language == None:
            language = self.lang

        if language == "bash":
            pass

        elif language == "ruby":
            pass

        elif language == "perl":
            pass

        elif language == "python":
            pass

        elif language == "php":
            pass

        elif language == "text":
            pass

        elif language == "metasploit":
            pass

        elif language == "jsp":
            pass

        else:
            try:
                # Execute the compilation command and handle errors
                print(infos.PROCESS + "COMPILING...")
                if os.system(self.command) == 0:
                    self.console.print(f"[[bold bright_green]+[/]] Exploit compiled with success in {self.EXPLOIT_PATH, name}",
                                       style="bright_white")
                else:
                    self.console.print(f"[[bold bright_red]![/]] Error during the compilation.",
                                       style="bright_red")

            except:
                self.console.print(f"[[bold bright_red]![/]] Error during the compilation.",
                                   style="bright_red")

    # Method to write the payload to a file
    def WritePayload(self, payload, cve, name_ext):

        # Write the payload to a file using CVE and name extension
        exploit = open(os.path.join(self.EXPLOIT_PATH, cve + "_" + name_ext), "wb")
        exploit.write(payload)
        exploit.close()

        # Display a success message along with file path
        self.console.print(f"[[bold bright_green]![/]] Exploit created in path: [bright_magenta underline bold]{self.EXPLOIT_PATH + str(name_ext)}[/]",
                           style="bright_white")
        self.console.print(
            f"[[bold bright_green]+[/]] Check the folder to read and execute the exploit.",
            style="bright_white")
        self.console.print(
            f"[[bold bright_magenta]*[/]] Remember to change and add necessary host information so the exploit succeeds!\n",
            style="bright_white")

    # Method to find CVEs in the scanner output and initiate exploit search
    def FindCVEsInDict(self):

        self.exploiter_output = self.scanner_output

        # Iterate through the scanner output and look for CVEs
        for ip, services in self.scanner_output.items():
            self.ip = ip
            self.console.print(f"Results of [cyan]{self.ip}[/]: ", style="bold bright_magenta")
            for port, details in services.items():
                if isinstance(details, dict):
                    self.console.print(f"[bright_magenta]{self.ip}[/] test [cyan]port {port}[/]: ", style="bold bright_magenta")
                    for key, value in details.items():
                        if isinstance(value, dict):  # Check if value is a dictionary
                            cve_info = value.get('cve', None)
                            if cve_info:
                                self.port = port
                                self.console.print(f"CVE: [bold underline red]{cve_info}[/]", style="bold red")
                                description = value.get('description', None)
                                cvss = value.get('cvss', None)
                                severity = value.get('severity', None)
                                if description:
                                    self.console.print(f"Description: [bright_white]{description}[/]", style="bold red")
                                if cvss:
                                    self.console.print(f"CVSS: [bright_white]{cvss}[/]", style="bold red")
                                if severity:
                                    self.console.print(f"Severity: [bright_white]{severity}[/]", style="bold red")
                        # Call the FindCVE method for each found CVE
                        if key.startswith('CVE-'):
                            self.FindCVE(key, value)

    # Method to find an exploit for a specific CVE
    def FindCVE(self, cve_id, dict_info):

        global name
        global payload
        global sub_url
        global name_ext

        # Strip the CVE identifier and construct the search URL
        cve = cve_id.strip('CVE-')
        self.console.print(f"Searching for exploits for {self.exploit_db}search?cve=[underline bold white]{cve}[/] \n", style="bold bright_magenta")

        # Fetch exploit information from the search URL
        url = self.exploit_db + "search?cve=" + cve
        sock_cve = requests.get(url, headers=self.header).json()
        sock_cve = json.dumps(sock_cve, sort_keys=False, indent=4)
        sock_cve = json.loads(sock_cve)
        sock_cve = sock_cve['data']

        if sock_cve == []:
            print(infos.ERROR + f"No exploits available yet for {cve} in ExploitDB. \n")
        # Loop through exploit entries and process each one
        for i in range(len(sock_cve)):
            try:
                # Fetch and process payload from ExploitDB
                cve_edb = sock_cve[i]['id']
                description = sock_cve[i]['description'][1]
                verified = bool(sock_cve[i]['verified'])

                exploit_info = {
                    'description':description,
                    'verified':verified,
                    'url':self.exploit_db + 'exploits/' + cve_edb
                }

                self.console.print(f"[[bright_white]{self.ip}:[bold]{self.port}[/][/] - [bold bright_magenta]{cve_id}[/]] Found! Exploit name: [bold bright_magenta]{description}[/]", style="bright_white")
                self.console.print(f"[[bold bright_yellow]?[/]] ExploitDB exploit ID: [bold bright_white]{cve_edb}[/]",
                                   style="bright_white")
                if verified:
                    self.console.print(f"[[bold bright_green]+[/]] The exploit is [bold bright_green underline]VERIFIED[/].",
                                   style="bright_white")
                else:
                    self.console.print(f"[[bold bright_red]-[/]] The exploit is [bold bright_red underline]NOT VERIFIED[/]. Use at your own risk.",
                                      style="bright_white")

                sock_edb = urllib.request.urlopen(self.exploit_db + "raw/" + cve_edb)
                payload = sock_edb.read()
                sock_edb.close()
                name = cve_edb
                socket = requests.get(self.exploit_db_git + "files_exploits.csv", headers=self.header)
                socket = re.findall(".*" + name + ".*", socket.text)
                sub_url = socket[0].split(',')[1]

                # Guess the exploit language
                self.GuessLang(sub_url, str(payload))
                self.console.print(f"[[bold bright_yellow]?[/]] Language of the script: [bold bright_white]{self.lang}[/]", style="bright_white")

                if self.lang == "bash":
                    name_ext = str(name) + ".sh"
                elif self.lang == "ruby":
                    name_ext = str(name) + ".rb"
                elif self.lang == "perl":
                    name_ext = str(name) + ".pl"
                elif self.lang == "python":
                    name_ext = str(name) + ".py"
                elif self.lang == "php":
                    name_ext = str(name) + ".php"
                elif self.lang == "c++":
                    name_ext = str(name) + ".cpp"
                elif self.lang == "c":
                    name_ext = str(name) + ".c"
                elif self.lang == "metasploit":
                    name_ext = str(name) + ".rb"
                elif self.lang == "text":
                    name_ext = str(name) + ".txt"
                elif self.lang == "jsp":
                    name_ext = str(name) + ".jsp"

                # Update the dictionary with the exploit description list.
                if 'exploits' not in dict_info:
                    dict_info['exploits'] = {}
                dict_info['exploits'][cve_edb] = exploit_info

                # Detects the compilation options of the exploit
                self.DetectCompilationOptions(payload, cve_id, name, name_ext)
                # Writes the payload in the specific file for the exploit using appropiate tagging
                self.WritePayload(payload, cve_id, name_ext)
                # Compiles the script
                self.Compilation(name, self.command, self.lang)

           # Exception handling
            except AttributeError:
                self.console.print(f"[[bold bright_red]![/]] CVE name seems to not be correct or something is wrong with the CVE.", style="bright_white")

            # Exception handling
            except IndexError:
                self.console.print(
                    f"[[bold bright_red]![/]] No exploits available for [bold]{cve_id}[/]",
                style="bright_white")

            except MarkupError:
                pass

    # Method to create a directory for storing exploits INSIDE THE PROJECT specified.
    def CreateDirectory(self):
        try:
            # Create the directory if it doesn't exist
            os.makedirs(self.EXPLOIT_PATH)
        except OSError:
            if not os.path.isdir(self.EXPLOIT_PATH):
                pass

    # Main exploit method
    def exploit(self):
        # Create the exploit directory if it doesn't exist
        self.CreateDirectory()
        # Find CVEs in the scanner output and initiate exploit search.
        self.FindCVEsInDict()

        return self.exploiter_output