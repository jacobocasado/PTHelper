# Import required libraries
import json
import os
import random
import re
import urllib
import requests

from rich.console import Console
from exploiter.info import infos, bcolors
from config.pthelper_config import general_config

# Define the base class Exploiter
class Exploiter:
    # Use __new__ to create a new instance of the scanner_class based on the provided mode
    def __new__(cls, mode, scanner_output):
        # A dictionary to map different exploiter modes to respective classes
        exploiter_classes = {
            "exploitdb": ExploitDBExploiter
            # For future exploiter modes, add the user-defined flag and the corresponding child class name here
        }
        # Get the exploiter from the dictionary, default is ExploitDB itself
        exploiter_class = exploiter_classes.get(mode, Exploiter)
        return super(Exploiter, cls).__new__(exploiter_class)

    def __init__(self, mode, scanner_output):
        self.mode = mode
        self.input = scanner_output
        self.console = Console()

        # Print an informative message
        self.console.print(f"Initializing {mode} Exploiter module on the CVEs provided by the scanner.")

# Define a child class ExploitDBExploiter, inheriting from Exploiter
class ExploitDBExploiter(Exploiter):

    # Call the parent class (scanner) to receive parameters.
    def __init__(self, mode, scanner_output):
        # Initialize attributes specific to ExploitDBExploiter
        self.mode = mode
        self.exploit_db = "https://www.exploit-db.com/"
        self.exploit_db_git = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/"
        self.command = ''
        self.usage = ''
        self.lang = None
        self.findlang = None
        self.scanner_output = scanner_output

        # Set the path for storing exploits
        self.EXPLOIT_PATH = os.path.join(general_config.PROJECTPATH, 'exploits/')

        # Read User-Agent headers from a file and select a random one
        ua = open('pthelper/exploiter/headers.txt').read().splitlines()
        self.header = {"User-Agent": random.choice(ua), "X-Requested-With": "XMLHttpRequest"}

        # Call the parent class constructor
        super().__init__(mode, scanner_output)

    # Method to detect compilation options based on payload and language
    def DetectCompilationOptions(self, payload, cve_id, name, name_ext):

        try:
            # Detect compilation options for C/C++
            if self.lang == "c" or self.lang == "c++":
                try:
                    # Try to extract compilation command from payload
                    self.command = re.search(r"((gcc|g\+\+) .*?)(\\r\\n|\\n)", str(payload)).group(1)

                    if self.command != '':
                        # Modify compilation command to include file paths
                        # and other necessary flags
                        self.command = re.sub(' \S*\.cpp', f' {self.EXPLOIT_PATH} ' + str(name) + '.cpp', self.command).strip(
                            "\"")
                        self.command = re.sub(' \S*\.c', f' {self.EXPLOIT_PATH} ' + str(name) + '.c', self.command).strip("\"")
                        self.command = re.sub('-o \S*', f'-o {self.EXPLOIT_PATH}' + str(name), self.command).strip("\"")

                        # Print detected compilation options
                        print(infos.INFO + "COMPILING OPTIONS DETECTED : " + self.command)

                except:
                    # If command extraction fails, use a default compilation command
                    self.command = f"gcc {self.EXPLOIT_PATH}" + cve_id + "_" + name_ext + f" -o {self.EXPLOIT_PATH}" + str(name)
                    # Print default compilation options
                    print(infos.INFO + "COMPILING OPTIONS NOT DETECTED, BY DEFAULT : " + self.command)

                payload_split = payload.splitlines()
                usage = re.search("(\.\/.*?)(\',/\",)", str(payload_split)).group(1)
                if usage != '':
                    usage = re.sub('(\.\/.*? )', f' {self.EXPLOIT_PATH}' + str(name) + ' ', usage)
                    print(infos.GOOD + "Usage detected: " + usage)

            # Detect compilation options for other languages (bash, ruby, perl, python, etc.)
            # Also, extract usage information and modify it based on exploit file paths
            elif self.lang == "bash":
                usage = re.search(r"(sh .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.sh', f' {self.EXPLOIT_PATH}' + str(name_ext), usage)
                    print(infos.GOOD + "Usage detected: " + usage)

            elif self.lang == "ruby":
                usage = re.search(r"(ruby .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.rb', f' {self.EXPLOIT_PATH}' + str(name_ext), usage)
                    print(infos.GOOD + "Usage detected: " + usage)

            elif self.lang == "perl":
                usage = re.search(r"(perl .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.pl', f' {self.EXPLOIT_PATH}' + str(name_ext), usage)
                    print(infos.GOOD + "Usage detected: " + usage)

            elif self.lang == "python":
                usage = re.search(r"(python .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.py', f' {self.EXPLOIT_PATH}' + str(name_ext), usage)
                    print(infos.GOOD + "Usage detected: " + usage)

            elif self.lang == "php":
                usage = re.search(r"(php .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.php', f' {self.EXPLOIT_PATH}' + str(name_ext), usage)
                    print(infos.GOOD + "Usage detected: " + usage)

        # Handle exceptions and set default usage information
        except AttributeError:
            # Set default usage information for different languages
            if self.lang == "c" or self.lang == "c++":
                usage = f"{self.EXPLOIT_PATH}" + str(name)
                print(infos.INFO + "Usage not detected, by default: " + usage)

            elif self.lang == "bash":
                usage = f"sh {self.EXPLOIT_PATH}" + str(name_ext)
                print(infos.INFO + "Usage not detected, by default: " + usage)

            elif self.lang == "ruby":
                usage = f"ruby {self.EXPLOIT_PATH}" + str(name_ext)
                print(infos.INFO + "Usage not detected, by default: " + usage)

            elif self.lang == "perl":
                usage = f"perl {self.EXPLOIT_PATH}" + str(name_ext)
                print(infos.INFO + "Usage not detected, by default: " + usage)

            elif self.lang == "python":
                usage = f"python {self.EXPLOIT_PATH}" + str(name_ext)
                print(infos.INFO + "Usage not detected, by default: " + usage)

            elif self.lang == "php":
                usage = f"php {self.EXPLOIT_PATH}" + str(name_ext)
                print(infos.INFO + "Usage not detected, by default: " + usage)

    # Method to guess programming language based on file extension and payload content
    def GuessLang(self, sub_url, payload):

        # Define wordlists to identify programming languages and frameworks
        metasploit_wordlist = ["MetasploitModule", "Msf::Exploit"]

        # Determine programming language based on file extension
        # Set appropriate language and color for display
        if sub_url[-4:] == ".cpp":
            self.findlang = " - " + bcolors.CYAN + bcolors.BOLD + "c++" + bcolors.ENDC + bcolors.ENDC
            self.lang = "c++"
        elif sub_url[-2:] == ".c":
            self.findlang = " - " + bcolors.CYAN + bcolors.BOLD + "c" + bcolors.ENDC + bcolors.ENDC
            self.lang = "c"
        elif sub_url[-3:] == ".sh":
            self.findlang = " - " + bcolors.GREEN + bcolors.BOLD + "sh" + bcolors.ENDC + bcolors.ENDC
            self.lang = "bash"
        elif sub_url[-3:] == ".rb":
            self.findlang = " - " + bcolors.RED + bcolors.BOLD + "ruby" + bcolors.ENDC + bcolors.ENDC
            self.lang = "ruby"
            for word in metasploit_wordlist:
                if word in payload:
                    self.findlang = " - " + bcolors.RED + bcolors.BOLD + "metasploit" + bcolors.ENDC + bcolors.ENDC
                    lang = "metasploit"
        elif sub_url[-3:] == ".pl":
            self.findlang = " - " + bcolors.PURPLE + bcolors.BOLD + "perl" + bcolors.ENDC + bcolors.ENDC
            self.lang = "perl"
        elif sub_url[-3:] == ".py":
            self.findlang = " - " + bcolors.OCRA + bcolors.BOLD + "python" + bcolors.ENDC + bcolors.ENDC
            self.lang = "python"
        elif sub_url[-4:] == ".php":
            self.findlang = " - " + bcolors.BLUE + bcolors.BOLD + "php" + bcolors.ENDC + bcolors.ENDC
            self.lang = "php"
        elif sub_url[-4:] == ".txt" or sub_url[-5:] == ".html":
            self.findlang = " - " + bcolors.BOLD + "text" + bcolors.ENDC
            self.lang = "text"
        elif sub_url[-4:] == ".jsp":
            self.findlang = " - " + bcolors.OCRA + bcolors.BOLD + "jsp" + bcolors.ENDC + bcolors.ENDC
            self.lang = "jsp"

    # Method to process and display information about found CVEs
    def CVEFound(self, detect_edb, description, sub_url):

        # Fetch payload content from ExploitDB
        sock_edb = urllib.request.urlopen(self.exploit_db_git + sub_url)
        payload = sock_edb.read()
        sock_edb.close()

        # Guess the programming language of the payload
        self.GuessLang(sub_url, str(payload))

        # Display exploit information and language
        if payload != "":
            if description == None:
                print(
                    bcolors.RED + bcolors.BOLD + "EDB-" + bcolors.ENDC + bcolors.ENDC + detect_edb + " : " + "No description found.")
            else:
                print(bcolors.RED + bcolors.BOLD + "EDB-" + bcolors.ENDC + bcolors.ENDC + detect_edb + " : " + str(
                    description) + self.findlang)

    # Method to search for CVEs related to a specific software version
    def Socket(self, software, url):

        socket = requests.get(url, headers=self.header)

        # Fetch data from the provided URL and filter relevant lines
        lines = socket.text.split('\n')
        # Search for CVEs related to the specified software version
        socket = re.findall(".*(?i)" + software + ".*", socket.text)

        # Display CVE information or a message if none are found
        if socket == None or socket == []:
            print(infos.GOOD + "No CVE found for this software version !")

        else:
            print(infos.GOOD + "EXPLOITS FOUND: ")
            for record in socket:
                record_split = record.split(',')
                try:
                    description = record_split[2]
                    detect_edb = record_split[0]
                    sub_url = record_split[1]
                except IndexError:
                    pass
                # Calls a method to process and display this information
                self.CVEFound(detect_edb, description, sub_url)

        return socket

    # Method to search for exploits related to a specific software.
    # This method calls another subroutine to perform its action.
    def SearchExploit(self, software):

        if software == None:
            pass

        # Display search progress and URL being used
        else:
            print(infos.PROCESS + "SEARCHING...")
            url = self.exploit_db_git + "files_exploits.csv"
            print(infos.INFO + "SEARCHING FOR : " + url + " - " + software)
            # Call the Socket method to search for exploits
            self.Socket(software, url)

    # Method to handle compilation of exploits in various languages
    def Compilation(self, name, command, language):

        # Set default compilation command for different languages
        if language == None:
            language = self.lang

        if language == "bash":
            pass

        elif language == "ruby":
            pass

        elif language == "perl":
            pass

        elif language == "python":
            pass

        elif language == "php":
            pass

        elif language == "text":
            pass

        elif language == "metasploit":
            pass

        elif language == "jsp":
            pass

        else:
            try:
                # Execute the compilation command and handle errors
                print(infos.PROCESS + "COMPILING...")
                if os.system(self.command) == 0:
                    print(infos.GOOD + "EXPLOIT COMPILED WITH SUCCESS : " + f"{self.EXPLOIT_PATH}" + name)
                else:
                    print("\n" + infos.ERROR + "/!\ Error during the compilation ! /!\ ")

            except:
                print("\n" + infos.ERROR + "/!\ Error during the compilation ! /!\ ")

    # Method to write the payload to a file
    def WritePayload(self, payload, cve, name_ext):

        # Write the payload to a file using CVE and name extension
        exploit = open(os.path.join(self.EXPLOIT_PATH, cve + "_" + name_ext), "wb")
        exploit.write(payload)
        exploit.close()

        # Display a success message along with file path
        print(infos.GOOD + "EXPLOIT CREATED in PATH: " + self.EXPLOIT_PATH + str(name_ext), end="\n")
        print(infos.GOOD + "Check the folder to read and execute the exploit. \n"
                           + infos.HELP + " Remember to change/add neccesary host information to be successful!\n")

    # Method to find CVEs in the scanner output and initiate exploit search
    def FindCVEsInDict(self):

        # Iterate through the scanner output and look for CVEs
        for ip, services in self.scanner_output.items():
            for port, details in services.items():
                if isinstance(details, dict):
                    for key in details.keys():
                        # Call the FindCVE method for each found CVE
                        if key.startswith('CVE-'):
                            print(key)
                            self.FindCVE(key)

    # Method to find an exploit for a specific CVE
    def FindCVE(self, cve_id):

        global name
        global payload
        global sub_url
        global name_ext

        # Strip the CVE identifier and construct the search URL
        cve = cve_id.strip('CVE-')
        print(infos.INFO + "Searching for exploits for " + self.exploit_db + "search?cve=" + cve)

        # Fetch exploit information from the search URL
        url = self.exploit_db + "search?cve=" + cve
        sock_cve = requests.get(url, headers=self.header).json()
        sock_cve = json.dumps(sock_cve, sort_keys=False, indent=4)
        sock_cve = json.loads(sock_cve)
        sock_cve = sock_cve['data']

        if sock_cve == []:
            print(infos.ERROR + f"No exploits available yet for {cve} in ExploitDB. \n")
        # Loop through exploit entries and process each one
        for i in range(len(sock_cve)):
            try:
                # Fetch and process payload from ExploitDB
                cve_edb = sock_cve[i]['id']
                description = sock_cve[i]['description'][1]
                verified = bool(sock_cve[i]['verified'])

                print(infos.GOOD + "Found! Exploit name: " + description)
                print(infos.INFO + "ExploitDB exploit ID: " + cve_edb)
                print((infos.GOOD + "Exploit verified" if verified else infos.WARNING + "Exploit NOT verified"))

                sock_edb = urllib.request.urlopen(self.exploit_db + "raw/" + cve_edb)
                payload = sock_edb.read()
                sock_edb.close()
                name = cve_edb
                socket = requests.get(self.exploit_db_git + "files_exploits.csv", headers=self.header)
                socket = re.findall(".*" + name + ".*", socket.text)
                sub_url = socket[0].split(',')[1]

                # Guess the exploit language
                self.GuessLang(sub_url, str(payload))

                print(infos.INFO + "Language of the script: " + self.lang + bcolors.ENDC + bcolors.ENDC)

                if self.lang == "bash":
                    name_ext = str(name) + ".sh"
                elif self.lang == "ruby":
                    name_ext = str(name) + ".rb"
                elif self.lang == "perl":
                    name_ext = str(name) + ".pl"
                elif self.lang == "python":
                    name_ext = str(name) + ".py"
                elif self.lang == "php":
                    name_ext = str(name) + ".php"
                elif self.lang == "c++":
                    name_ext = str(name) + ".cpp"
                elif self.lang == "c":
                    name_ext = str(name) + ".c"
                elif self.lang == "metasploit":
                    name_ext = str(name) + ".rb"
                elif self.lang == "text":
                    name_ext = str(name) + ".txt"
                elif self.lang == "jsp":
                    name_ext = str(name) + ".jsp"

                # Detects the compilation options of the exploit
                self.DetectCompilationOptions(payload, cve_id, name, name_ext)
                # Writes the payload in the specific file for the exploit using appropiate tagging
                self.WritePayload(payload, cve_id, name_ext)
                # Compiles the script
                self.Compilation(name, self.command, self.lang)

           # Exception handling
            except AttributeError:
                print(infos.ERROR + "CVE name seems to not be correct or something is wrong with the CVE.")

            # Exception handling
            except IndexError:
                print(infos.ERROR + f"No exploits available for {cve} in ExploitDB.\n")

    # Method to create a directory for storing exploits INSIDE THE PROJECT specified.
    def CreateDirectory(self):
        try:
            # Create the directory if it doesn't exist
            print(general_config.PROJECTPATH)
            os.makedirs(self.EXPLOIT_PATH)
        except OSError:
            if not os.path.isdir(self.EXPLOIT_PATH):
                pass

    # Main exploit method
    def exploit(self):
        # Create the exploit directory if it doesn't exist
        self.CreateDirectory()
        # Find CVEs in the scanner output and initiate exploit search.
        self.FindCVEsInDict()