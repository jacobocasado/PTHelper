import json
import os
import random
import re
import urllib

import requests
from rich.console import Console

from exploiter.info import infos, bcolors
from pthelper_config import general_config


class Exploiter:
    # Use __new__ to create a new instance of the scanner_class based on the provided mode
    def __new__(cls, mode, scanner_output):
        # A dictionary to map different scanning modes to respective classes
        exploiter_classes = {
            "exploitdb": ExploitDBExploiter
            # For future exploiter modes, add the user-defined flag and the corresponding child class name here
        }
        # Get the exploiter from the dictionary, default is ExploitDB itself
        exploiter_class = exploiter_classes.get(mode, Exploiter)
        return super(Exploiter, cls).__new__(exploiter_class)

    def __init__(self, mode, scanner_output):
        self.mode = mode
        self.input = scanner_output
        self.console = Console()

        # Informative message
        self.console.print(f"Initializing {mode} Exploiter module on the CVEs provided by the scanner.")


class ExploitDBExploiter(Exploiter):

    # Call the parent class (scanner) to receive parameters.
    def __init__(self, mode, scanner_output):
        self.mode = mode
        self.exploit_db = "https://www.exploit-db.com/"
        self.exploit_db_git = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/"
        self.command = ''
        self.usage = ''
        self.lang = None
        self.findlang = None
        self.scanner_output = scanner_output

        ua = open('pthelper/exploiter/headers.txt').read().splitlines()
        self.header = {"User-Agent": random.choice(ua), "X-Requested-With": "XMLHttpRequest"}

        super().__init__(mode, scanner_output)

    def DetectCompilationOptions(self, payload, name, name_ext):

        try:
            if self.lang == "c" or self.lang == "c++":
                try:
                    self.command = re.search(r"((gcc|g\+\+) .*?)(\\r\\n|\\n)", str(payload)).group(1)
                    if self.command != '':
                        self.command = re.sub(' \S*\.cpp', ' /tmp/exploits/' + str(name) + '.cpp', self.command).strip(
                            "\"")
                        self.command = re.sub(' \S*\.c', ' /tmp/exploits/' + str(name) + '.c', self.command).strip("\"")
                        self.command = re.sub('-o \S*', '-o /tmp/exploits/' + str(name), self.command).strip("\"")
                        print(infos.INFO + "COMPILING OPTIONS DETECTED : " + self.command)

                except:
                    self.command = "gcc /tmp/exploits/" + str(name_ext) + " -o /tmp/exploits/" + str(name)
                    print(infos.INFO + "COMPILING OPTIONS NOT DETECTED, BY DEFAULT : " + self.command)

                payload_split = payload.splitlines()
                usage = re.search("(\.\/.*?)(\',/\",)", str(payload_split)).group(1)
                if usage != '':
                    usage = re.sub('(\.\/.*? )', ' /tmp/exploits/' + str(name) + ' ', usage)
                    print(infos.GOOD + "Usage detected: " + usage)

            elif self.lang == "bash":
                usage = re.search(r"(sh .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.sh', ' /tmp/exploits/' + str(name_ext), usage)
                    print(infos.GOOD + "Usage detected: " + usage)

            elif self.lang == "ruby":
                usage = re.search(r"(ruby .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.rb', ' /tmp/exploits/' + str(name_ext), usage)
                    print(infos.GOOD + "Usage detected: " + usage)

            elif self.lang == "perl":
                usage = re.search(r"(perl .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.pl', ' /tmp/exploits/' + str(name_ext), usage)
                    print(infos.GOOD + "Usage detected: " + usage)

            elif self.lang == "python":
                usage = re.search(r"(python .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.py', ' /tmp/exploits/' + str(name_ext), usage)
                    print(infos.GOOD + "Usage detected: " + usage)

            elif self.lang == "php":
                usage = re.search(r"(php .*?)\\r\\n", str(payload)).group(1)
                if usage != '':
                    usage = re.sub(' \S*\.php', ' /tmp/exploits/' + str(name_ext), usage)
                    print(infos.GOOD + "Usage detected: " + usage)

        except AttributeError:
            if self.lang == "c" or self.lang == "c++":
                usage = "/tmp/exploits/" + str(name)
                print(infos.INFO + "Usage not detected, by default: " + usage)

            elif self.lang == "bash":
                usage = "sh /tmp/exploits/" + str(name_ext)
                print(infos.INFO + "Usage not detected, by default: " + usage)

            elif self.lang == "ruby":
                usage = "ruby /tmp/exploits/" + str(name_ext)
                print(infos.INFO + "Usage not detected, by default: " + usage)

            elif self.lang == "perl":
                usage = "perl /tmp/exploits/" + str(name_ext)
                print(infos.INFO + "Usage not detected, by default: " + usage)

            elif self.lang == "python":
                usage = "python /tmp/exploits/" + str(name_ext)
                print(infos.INFO + "Usage not detected, by default: " + usage)

            elif self.lang == "php":
                usage = "php /tmp/exploits/" + str(name_ext)
                print(infos.INFO + "Usage not detected, by default: " + usage)

    def GuessLang(self, sub_url, payload):

        metasploit_wordlist = ["MetasploitModule", "Msf::Exploit"]
        if sub_url[-4:] == ".cpp":
            self.findlang = " - " + bcolors.CYAN + bcolors.BOLD + "c++" + bcolors.ENDC + bcolors.ENDC
            self.lang = "c++"
        elif sub_url[-2:] == ".c":
            self.findlang = " - " + bcolors.CYAN + bcolors.BOLD + "c" + bcolors.ENDC + bcolors.ENDC
            self.lang = "c"
        elif sub_url[-3:] == ".sh":
            self.findlang = " - " + bcolors.GREEN + bcolors.BOLD + "sh" + bcolors.ENDC + bcolors.ENDC
            self.lang = "bash"
        elif sub_url[-3:] == ".rb":
            self.findlang = " - " + bcolors.RED + bcolors.BOLD + "ruby" + bcolors.ENDC + bcolors.ENDC
            self.lang = "ruby"
            for word in metasploit_wordlist:
                if word in payload:
                    self.findlang = " - " + bcolors.RED + bcolors.BOLD + "metasploit" + bcolors.ENDC + bcolors.ENDC
                    lang = "metasploit"
        elif sub_url[-3:] == ".pl":
            self.findlang = " - " + bcolors.PURPLE + bcolors.BOLD + "perl" + bcolors.ENDC + bcolors.ENDC
            self.lang = "perl"
        elif sub_url[-3:] == ".py":
            self.findlang = " - " + bcolors.OCRA + bcolors.BOLD + "python" + bcolors.ENDC + bcolors.ENDC
            self.lang = "python"
        elif sub_url[-4:] == ".php":
            self.findlang = " - " + bcolors.BLUE + bcolors.BOLD + "php" + bcolors.ENDC + bcolors.ENDC
            self.lang = "php"
        elif sub_url[-4:] == ".txt" or sub_url[-5:] == ".html":
            self.findlang = " - " + bcolors.BOLD + "text" + bcolors.ENDC
            self.lang = "text"
        elif sub_url[-4:] == ".jsp":
            self.findlang = " - " + bcolors.OCRA + bcolors.BOLD + "jsp" + bcolors.ENDC + bcolors.ENDC
            self.lang = "jsp"

    def CVEFound(self, detect_edb, description, sub_url):
        sock_edb = urllib.request.urlopen(self.exploit_db_git + sub_url)
        payload = sock_edb.read()
        sock_edb.close()

        self.GuessLang(sub_url, str(payload))

        if payload != "":
            if description == None:
                print(
                    bcolors.RED + bcolors.BOLD + "EDB-" + bcolors.ENDC + bcolors.ENDC + detect_edb + " : " + "No description found.")
            else:
                print(bcolors.RED + bcolors.BOLD + "EDB-" + bcolors.ENDC + bcolors.ENDC + detect_edb + " : " + str(
                    description) + self.findlang)

    def Socket(self, software, url):

        global socket

        socket = requests.get(url, headers=self.header)

        lines = socket.text.split('\n')
        socket = re.findall(".*(?i)" + software + ".*", socket.text)

        if socket == None or socket == []:
            print("\n" + infos.GOOD + "No CVE found for this software version !")

        else:
            print(infos.GOOD + "EXPLOITS FOUND : " + "\n")
            for record in socket:
                record_split = record.split(',')
                try:
                    description = record_split[2]
                    detect_edb = record_split[0]
                    sub_url = record_split[1]
                except IndexError:
                    pass

                self.CVEFound(detect_edb, description, sub_url)

        print()
        return socket

    def SearchExploit(self, software):

        if software == None:
            pass

        else:
            print(infos.PROCESS + "SEARCHING...")
            url = self.exploit_db_git + "files_exploits.csv"
            print(infos.INFO + "SEARCHING FOR : " + url + " - " + software)
            print()
            self.Socket(software, url)

    def Compilation(self, name, command, language):

        if language == None:
            language = self.lang

        if language == "bash":
            pass

        elif language == "ruby":
            pass

        elif language == "perl":
            pass

        elif language == "python":
            pass

        elif language == "php":
            pass

        elif language == "text":
            pass

        elif language == "metasploit":
            pass

        elif language == "jsp":
            pass

        else:
            try:
                print(infos.PROCESS + "COMPILING...")
                if os.system(self.command) == 0:
                    print(infos.GOOD + "EXPLOIT COMPILED WITH SUCCESS : " + "/tmp/exploits/" + name + "\n")
                else:
                    exit()

            except:
                print("\n" + infos.ERROR + "/!\ Error during the compilation ! /!\ ")
                exit()

    def WritePayload(self, payload, name_ext):
        exploit = open("/tmp/exploits/" + str(name_ext), "wb")
        exploit.write(payload)
        exploit.close()
        print(infos.GOOD + "EXPLOIT CREATED : " + "/tmp/exploits/" + str(name_ext) + "\n")

    def FindCVEsInDict(self):
        for ip, services in self.scanner_output.items():
            for port, details in services.items():
                if isinstance(details, dict):
                    for key in details.keys():
                        if key.startswith('CVE-'):
                            self.FindCVE(key)

    def FindCVE(self, cve):

        global name
        global payload
        global sub_url
        global name_ext

        cve = cve.strip('CVE-')
        print("\n" + infos.INFO + "Searching for exploits for " + self.exploit_db + "search?cve=" + cve)
        url = self.exploit_db + "search?cve=" + cve
        sock_cve = requests.get(url, headers=self.header).json()
        sock_cve = json.dumps(sock_cve, sort_keys=False, indent=4)
        sock_cve = json.loads(sock_cve)
        sock_cve = sock_cve['data']

        if sock_cve == []:
            print("\n" + infos.ERROR + f"No exploits available yet for {cve} in ExploitDB.\n")
        for i in range(len(sock_cve)):
            try:
                cve_edb = sock_cve[i]['id']
                description = sock_cve[i]['description'][1]
                print(infos.GOOD + "Found! Exploit name: " + description)
                print(infos.INFO + "ExploitDB exploit ID: " + cve_edb)
                sock_edb = urllib.request.urlopen(self.exploit_db + "raw/" + cve_edb)
                payload = sock_edb.read()
                sock_edb.close()
                name = cve_edb
                socket = requests.get(self.exploit_db_git + "files_exploits.csv", headers=self.header)
                socket = re.findall(".*" + name + ".*", socket.text)
                sub_url = socket[0].split(',')[1]

                self.GuessLang(sub_url, str(payload))

                print(infos.INFO + "Language of the script: " + self.lang + bcolors.ENDC + bcolors.ENDC)

                if self.lang == "bash":
                    name_ext = str(name) + ".sh"
                elif self.lang == "ruby":
                    name_ext = str(name) + ".rb"
                elif self.lang == "perl":
                    name_ext = str(name) + ".pl"
                elif self.lang == "python":
                    name_ext = str(name) + ".py"
                elif self.lang == "php":
                    name_ext = str(name) + ".php"
                elif self.lang == "c++":
                    name_ext = str(name) + ".cpp"
                elif self.lang == "c":
                    name_ext = str(name) + ".c"
                elif self.lang == "metasploit":
                    name_ext = str(name) + ".rb"
                elif self.lang == "text":
                    name_ext = str(name) + ".txt"
                elif self.lang == "jsp":
                    name_ext = str(name) + ".jsp"

                self.DetectCompilationOptions(payload, name, name_ext)
                self.WritePayload(payload, name_ext)
                self.Compilation(name, self.command, self.lang)

            except AttributeError:
                print("\n" + infos.ERROR + "CVE name seems to not be correct or something is wrong with the CVE.\n")

            except IndexError:
                print("\n" + infos.ERROR + "No exploits available for this CVE in ExploitDB\n")

    def CreateDirectory(self):
        try:
            general_config.PROJECTPATH = '../../projects/tfm'
            os.makedirs(os.path.join(general_config.PROJECTPATH, 'exploits'))
        except OSError:
            if not os.path.isdir("/tmp/exploits"):
                pass

    def exploit(self):
        self.FindCVEsInDict()


# Main script entry point
if __name__ == '__main__':
    main()
